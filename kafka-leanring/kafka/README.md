## kafka producer.acks:
* acks=0，生产者成功写入消息之前不会等待来自任何服务器的响应，这种配置，提高吞吐量，但是消息存在丢失风险。
* acks=1，只要集群的`leader（master）首领节点`收到了消息，生产者将会受到发送成功的一个响应，如果消息无撞到达首领节点（比如首领节点崩愤，新的首领还没有被选举出来），生产者会收到一个错误响应，为了避免数据丢失，生产者会重发消息。不过，如果一个没有收到消息的节点成为新首领，消息还是会丢失。这个时候的吞吐量取决于使用的是
   同步发送还是异步发送。如果让发送客户端等待服务器的响应（通过调用Futu re 对象的get（）方法，显然会增加延迟（在网络上传输一个来回的延迟）。如果客户端使用回调，延迟问题就可以得到缓解，不过吞吐量还是会受发送中消息数量的限制（比如，生产者在收到服务器响应之前可以发送多少个消息）。
* 如果acks=all / -1，只有在集群所有的跟随副本都接收到消息后，生产者才会受到一个来自服务器的成功响应。这种模式是最安全的，它可以保证集群中不止一个服务器接收到消息，就算有服务器崩溃了，这个集群还是能够正常运行。不过它比acks=1的延迟性更高，因为生产者要等待的所有参与复制消息的节点接收到消息。

一般使用acks = 1,注意即使acks为all的时候也不能保证百分百的数据不丢失

## 消费者
```
spring:
  kafka:
    bootstrap-servers: 127.0.0.1:9092
```